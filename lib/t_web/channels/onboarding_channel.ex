defmodule TWeb.OnboardingChannel do
  use TWeb, :channel
  alias T.Accounts.User
  alias T.{Accounts, Media}
  alias TWeb.{ErrorView, ProfileView}

  @impl true
  def join("onboarding:" <> user_id, _params, socket) do
    ChannelHelpers.verify_user_id(socket, user_id)
    %User{profile: profile} = Accounts.ensure_profile(ChannelHelpers.current_user(socket))
    {:ok, %{profile: render_profile(profile)}, assign(socket, uploads: %{}, profile: profile)}
  end

  defp render_profile(profile) do
    render(ProfileView, "show.json", profile: profile)
  end

  @impl true
  def handle_in("upload-preflight", %{"content-type" => content_type}, socket) do
    # TODO validate content type
    key = Media.public_key()

    {:ok, fields} =
      T.Media.sign_form_upload(
        key: key,
        content_type: content_type,
        max_file_size: 8_000_000,
        expires_in: :timer.hours(1)
      )

    uploads = socket.assigns.uploads
    socket = assign(socket, uploads: Map.put(uploads, key, nil))
    {:reply, {:ok, %{url: Media.url(), key: key, fields: fields}}, socket}
  end

  def handle_in("submit", params, socket) do
    run_and_reply(socket, fn profile -> Accounts.update_profile(profile, params) end)
  end

  # TODO store current step in assigns and ask for transition to the next step?
  def handle_in("validate", %{"step" => step}, socket) do
    validation =
      case step do
        "photos" ->
          # TODO ensure provided keys exist on s3 and have been generated by this process
          fn profile -> Accounts.validate_profile_photos(profile) end

        "general-info" ->
          fn profile -> Accounts.validate_profile_general_info(profile) end

        "work-and-education" ->
          fn profile -> Accounts.validate_profile_work_and_education(profile) end

        "about" ->
          fn profile -> Accounts.validate_profile_about(profile) end

        "tastes" ->
          fn profile -> Accounts.validate_profile_tastes(profile) end

        # TODO we can close the channel now
        "final" ->
          fn profile -> Accounts.finish_onboarding(profile.user_id) end
      end

    run_and_reply(socket, validation)
  end

  defp run_and_reply(socket, fun) do
    case fun.(socket.assigns.profile) do
      {:ok, profile} ->
        socket = assign(socket, profile: profile)
        {:reply, {:ok, %{profile: render_profile(profile)}}, socket}

      {:error, changeset} ->
        {:reply, {:error, render(ErrorView, "changeset.json", changeset: changeset)}, socket}
    end
  end
end
